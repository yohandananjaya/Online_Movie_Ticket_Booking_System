"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.InngestFunction = void 0;
const consts_js_1 = require("../helpers/consts.js");
const strings_js_1 = require("../helpers/strings.js");
const InngestExecution_js_1 = require("./execution/InngestExecution.js");
const v0_js_1 = require("./execution/v0.js");
const v1_js_1 = require("./execution/v1.js");
const v2_js_1 = require("./execution/v2.js");
/**
 * A stateless Inngest function, wrapping up function configuration and any
 * in-memory steps to run when triggered.
 *
 * This function can be "registered" to create a handler that Inngest can
 * trigger remotely.
 *
 * @public
 */
class InngestFunction {
    /**
     * A stateless Inngest function, wrapping up function configuration and any
     * in-memory steps to run when triggered.
     *
     * This function can be "registered" to create a handler that Inngest can
     * trigger remotely.
     */
    constructor(client, 
    /**
     * Options
     */
    opts, fn) {
        this.client = client;
        this.opts = opts;
        this.fn = fn;
        this.onFailureFn = this.opts.onFailure;
        this.middleware = this.client["initializeMiddleware"](this.opts.middleware, { registerInput: { fn: this }, prefixStack: this.client["middleware"] });
    }
    /**
     * The generated or given ID for this function.
     */
    id(prefix) {
        return [prefix, this.opts.id].filter(Boolean).join("-");
    }
    /**
     * The generated or given ID for this function, prefixed with the app ID. This
     * is used for routing invokes and identifying the function across apps.
     */
    get absoluteId() {
        return this.id(this.client.id);
    }
    /**
     * The name of this function as it will appear in the Inngest Cloud UI.
     */
    get name() {
        return this.opts.name || this.id();
    }
    /**
     * The description of this function.
     */
    get description() {
        return this.opts.description;
    }
    /**
     * Retrieve the Inngest config for this function.
     */
    getConfig({ baseUrl, appPrefix, isConnect, }) {
        var _a, _b;
        const fnId = this.id(appPrefix);
        const stepUrl = new URL(baseUrl.href);
        stepUrl.searchParams.set(consts_js_1.queryKeys.FnId, fnId);
        stepUrl.searchParams.set(consts_js_1.queryKeys.StepId, InngestFunction.stepId);
        const { retries: attempts, cancelOn, idempotency, batchEvents, rateLimit, throttle, concurrency, debounce, timeouts, priority, singleton, } = this.opts;
        /**
         * Convert retries into the format required when defining function
         * configuration.
         */
        const retries = typeof attempts === "undefined" ? undefined : { attempts };
        const fn = {
            id: fnId,
            name: this.name,
            triggers: ((_a = this.opts.triggers) !== null && _a !== void 0 ? _a : []).map((trigger) => {
                if ("event" in trigger) {
                    return {
                        event: trigger.event,
                        expression: trigger.if,
                    };
                }
                return {
                    cron: trigger.cron,
                };
            }),
            steps: {
                [InngestFunction.stepId]: {
                    id: InngestFunction.stepId,
                    name: InngestFunction.stepId,
                    runtime: {
                        type: isConnect ? "ws" : "http",
                        url: stepUrl.href,
                    },
                    retries,
                },
            },
            idempotency,
            batchEvents,
            rateLimit,
            throttle,
            concurrency,
            debounce,
            priority,
            timeouts,
            singleton,
        };
        if (cancelOn) {
            fn.cancel = cancelOn.map(({ event, timeout, if: ifStr, match }) => {
                const ret = {
                    event,
                };
                if (timeout) {
                    ret.timeout = (0, strings_js_1.timeStr)(timeout);
                }
                if (match) {
                    ret.if = `event.${match} == async.${match}`;
                }
                else if (ifStr) {
                    ret.if = ifStr;
                }
                return ret;
            }, []);
        }
        const config = [fn];
        if (this.onFailureFn) {
            const id = `${fn.id}${InngestFunction.failureSuffix}`;
            const name = `${(_b = fn.name) !== null && _b !== void 0 ? _b : fn.id} (failure)`;
            const failureStepUrl = new URL(stepUrl.href);
            failureStepUrl.searchParams.set(consts_js_1.queryKeys.FnId, id);
            config.push({
                id,
                name,
                triggers: [
                    {
                        event: consts_js_1.internalEvents.FunctionFailed,
                        expression: `event.data.function_id == '${fnId}'`,
                    },
                ],
                steps: {
                    [InngestFunction.stepId]: {
                        id: InngestFunction.stepId,
                        name: InngestFunction.stepId,
                        runtime: {
                            type: "http",
                            url: failureStepUrl.href,
                        },
                        retries: { attempts: 1 },
                    },
                },
            });
        }
        return config;
    }
    createExecution(opts) {
        const options = Object.assign({ fn: this }, opts.partialOptions);
        const versionHandlers = {
            [InngestExecution_js_1.ExecutionVersion.V2]: () => (0, v2_js_1.createV2InngestExecution)(options),
            [InngestExecution_js_1.ExecutionVersion.V1]: () => (0, v1_js_1.createV1InngestExecution)(options),
            [InngestExecution_js_1.ExecutionVersion.V0]: () => (0, v0_js_1.createV0InngestExecution)(options),
        };
        return versionHandlers[opts.version]();
    }
    shouldOptimizeParallelism() {
        var _a, _b;
        // TODO We should check the commhandler's client instead of this one?
        return ((_b = (_a = this.opts.optimizeParallelism) !== null && _a !== void 0 ? _a : this.client["options"].optimizeParallelism) !== null && _b !== void 0 ? _b : false);
    }
}
exports.InngestFunction = InngestFunction;
InngestFunction.stepId = "step";
InngestFunction.failureSuffix = "-failure";
//# sourceMappingURL=InngestFunction.js.map