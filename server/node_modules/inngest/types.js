"use strict";
/**
 * Internal types and schemas used throughout the Inngest SDK.
 *
 * Note that types intended to be imported and utilized in userland code will be
 * exported from the main entrypoint of the SDK, `inngest`; importing types
 * directly from this file may result in breaking changes in non-major bumps as
 * only those exported from `inngest` are considered stable.
 *
 * @module
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.inBandSyncRequestBodySchema = exports.err = exports.ok = exports.functionConfigSchema = exports.logLevels = exports.sendEventResponseSchema = exports.incomingOpSchema = exports.StepOpCode = exports.jsonErrorSchema = void 0;
const zod_1 = require("zod");
const baseJsonErrorSchema = zod_1.z.object({
    name: zod_1.z.string().trim().optional(),
    error: zod_1.z.string().trim().optional(),
    message: zod_1.z.string().trim().optional(),
    stack: zod_1.z.string().trim().optional(),
});
const maybeJsonErrorSchema = zod_1.z.lazy(() => zod_1.z.object({
    name: zod_1.z.string().trim(),
    message: zod_1.z.string().trim(),
    stack: zod_1.z.string().trim().optional(),
    cause: zod_1.z.union([maybeJsonErrorSchema, zod_1.z.unknown()]).optional(),
}));
exports.jsonErrorSchema = baseJsonErrorSchema
    .extend({
    cause: zod_1.z.union([maybeJsonErrorSchema, zod_1.z.unknown()]).optional(),
})
    .passthrough()
    .catch({})
    .transform((val) => {
    return Object.assign(Object.assign({}, val), { name: val.name || "Error", message: val.message || val.error || "Unknown error", stack: val.stack });
});
/**
 * Unique codes for the different types of operation that can be sent to Inngest
 * from SDK step functions.
 */
var StepOpCode;
(function (StepOpCode) {
    StepOpCode["WaitForSignal"] = "WaitForSignal";
    StepOpCode["WaitForEvent"] = "WaitForEvent";
    /**
     * Legacy equivalent to `"StepRun"`. Has mixed data wrapping (e.g. `data` or
     * `data.data` depending on SDK version), so this is phased out in favour of
     * `"StepRun"`, which never wraps.
     *
     * Note that it is still used for v0 executions for backwards compatibility.
     *
     * @deprecated Only used for v0 executions; use `"StepRun"` instead.
     */
    StepOpCode["Step"] = "Step";
    StepOpCode["StepRun"] = "StepRun";
    StepOpCode["StepError"] = "StepError";
    StepOpCode["StepPlanned"] = "StepPlanned";
    StepOpCode["Sleep"] = "Sleep";
    /**
     * Used to signify that the executor has requested that a step run, but we
     * could not find that step.
     *
     * This is likely indicative that a step was renamed or removed from the
     * function.
     */
    StepOpCode["StepNotFound"] = "StepNotFound";
    StepOpCode["InvokeFunction"] = "InvokeFunction";
    StepOpCode["AiGateway"] = "AIGateway";
    StepOpCode["Gateway"] = "Gateway";
})(StepOpCode || (exports.StepOpCode = StepOpCode = {}));
exports.incomingOpSchema = zod_1.z.object({
    id: zod_1.z.string().min(1),
    data: zod_1.z.any().optional(),
    error: zod_1.z.any().optional(),
    input: zod_1.z.any().optional(),
});
exports.sendEventResponseSchema = zod_1.z.object({
    /**
     * Event IDs
     */
    ids: zod_1.z.array(zod_1.z.string()).default([]),
    /**
     * HTTP Status Code. Will be undefined if no request was sent.
     */
    status: zod_1.z.number().default(0),
    /**
     * Error message. Will be undefined if no error occurred.
     */
    error: zod_1.z.string().optional(),
});
/**
 * A set of log levels that can be used to control the amount of logging output
 * from various parts of the Inngest library.
 *
 * @public
 */
exports.logLevels = [
    "fatal",
    "error",
    "warn",
    "info",
    "debug",
    "silent",
];
/**
 * This schema is used internally to share the shape of a concurrency option
 * when validating config. We cannot add comments to Zod fields, so we just use
 * an extra type check to ensure it matches our exported expectations.
 */
const concurrencyOptionSchema = zod_1.z.strictObject({
    limit: zod_1.z.number(),
    key: zod_1.z.string().optional(),
    scope: zod_1.z.enum(["fn", "env", "account"]).optional(),
});
const _checkConcurrencySchemaAligns = true;
/**
 * The schema used to represent an individual function being synced with
 * Inngest.
 *
 * Note that this should only be used to validate the shape of a config object
 * and not used for feature compatibility, such as feature X being exclusive
 * with feature Y; these should be handled on the Inngest side.
 */
exports.functionConfigSchema = zod_1.z.strictObject({
    name: zod_1.z.string().optional(),
    id: zod_1.z.string(),
    triggers: zod_1.z.array(zod_1.z.union([
        zod_1.z.strictObject({
            event: zod_1.z.string(),
            expression: zod_1.z.string().optional(),
        }),
        zod_1.z.strictObject({
            cron: zod_1.z.string(),
        }),
    ])),
    steps: zod_1.z.record(zod_1.z.strictObject({
        id: zod_1.z.string(),
        name: zod_1.z.string(),
        runtime: zod_1.z.strictObject({
            type: zod_1.z.union([zod_1.z.literal("http"), zod_1.z.literal("ws")]),
            url: zod_1.z.string(),
        }),
        retries: zod_1.z
            .strictObject({
            attempts: zod_1.z.number().optional(),
        })
            .optional(),
    })),
    idempotency: zod_1.z.string().optional(),
    batchEvents: zod_1.z
        .strictObject({
        maxSize: zod_1.z.number(),
        timeout: zod_1.z.string(),
        key: zod_1.z.string().optional(),
        if: zod_1.z.string().optional(),
    })
        .optional(),
    rateLimit: zod_1.z
        .strictObject({
        key: zod_1.z.string().optional(),
        limit: zod_1.z.number(),
        period: zod_1.z.string().transform((x) => x),
    })
        .optional(),
    throttle: zod_1.z
        .strictObject({
        key: zod_1.z.string().optional(),
        limit: zod_1.z.number(),
        period: zod_1.z.string().transform((x) => x),
        burst: zod_1.z.number().optional(),
    })
        .optional(),
    singleton: zod_1.z
        .strictObject({
        key: zod_1.z.string().optional(),
        mode: zod_1.z.enum(["skip", "cancel"]),
    })
        .optional(),
    cancel: zod_1.z
        .array(zod_1.z.strictObject({
        event: zod_1.z.string(),
        if: zod_1.z.string().optional(),
        timeout: zod_1.z.string().optional(),
    }))
        .optional(),
    debounce: zod_1.z
        .strictObject({
        key: zod_1.z.string().optional(),
        period: zod_1.z.string().transform((x) => x),
        timeout: zod_1.z
            .string()
            .transform((x) => x)
            .optional(),
    })
        .optional(),
    timeouts: zod_1.z
        .strictObject({
        start: zod_1.z
            .string()
            .transform((x) => x)
            .optional(),
        finish: zod_1.z
            .string()
            .transform((x) => x)
            .optional(),
    })
        .optional(),
    priority: zod_1.z
        .strictObject({
        run: zod_1.z.string().optional(),
    })
        .optional(),
    concurrency: zod_1.z
        .union([
        zod_1.z.number(),
        concurrencyOptionSchema.transform((x) => x),
        zod_1.z
            .array(concurrencyOptionSchema.transform((x) => x))
            .min(1)
            .max(2),
    ])
        .optional(),
});
const ok = (data) => {
    return { ok: true, value: data };
};
exports.ok = ok;
const err = (error) => {
    return { ok: false, error };
};
exports.err = err;
exports.inBandSyncRequestBodySchema = zod_1.z.strictObject({
    url: zod_1.z.string(),
});
//# sourceMappingURL=types.js.map